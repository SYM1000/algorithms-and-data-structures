*****   Estructura de datos *****

NOTAS:
* Modelo de computación: es la definición un conjunto de operaciones permitibles usadas en el cómputo y sus respectivos costos.
* Tiempo de ejecución: al intervalo de tiempo en el que un programa de computadora se ejecuta en un sistema operativo.
* El Análisis de Algoritmos: es una parte importante de la Teoría de complejidad computacional más amplia, 
                             que provee estimaciones teóricas para los recursos que necesita cualquier algoritmo que resuelva un problema computacional dado. 
                             Estas estimaciones resultan ser bastante útiles en la búsqueda de algoritmos eficientes.
* Numero de Operaciones: costo de calculo, es decir, cual es el número de operaciones que deberian realizarse para completarlo y obtener el resultado que estamos buscando.
                         Esto permite calificar el algoritmo y comparar su eficiencia con respecto a otro que resuelva el mismo problema.
                        - Operaciones de punto flotante, flops. Estas operaciones son las de suma, resta, multiplicaci ́on y divisi ́on.
* Podemos utilizar la notación “O” para calificar el costo de cálculo.
* Debemos tener presente que en el costo computacional de un algoritmo hay mucho máss que el número de operaciones que el mismo requiere. Por ejemplo,
  en una computadora que cuente con un único procesador, el tiempo de ejecución está afectado por el movimiento de los datos entre distintos componentes 
  de la memoria y por otros trabajos que estén ejecutándose al mismo tiempo. En una máquina con un procesador múltiple, también hay que tener en cuenta 
  el tiempo empleado en la comunicación entre procesadores. Por el momento sólo nos enfocaremos en lo que respecta a la aritmética de un algoritmo.






Algoritmos de ordenamiento: 
    - Un "buen algoritmo" de ordenamiento requiere de un orden nlogn comparaciones.
    - Recursos:
        https://www.monografias.com/trabajos/algordenam/algordenam.shtml

    1. Bubble sort:
       * Recursos:
            - https://www.ecured.cu/Ordenamiento_de_burbuja
            - geekpedia de ernesto

        * Compara dos numeros entre si para poder ir haciendo el ordenmaineto de menor a mayor.
        * Puede ordenar de menor a mayor o viceversa.
        * número de comparaciones pertenece al orden de n cuadrado.
        * A pesar de que el ordenamiento de burbuja es uno de los algoritmos más sencillos de implementar, su orden O(n2) 
          lo hace muy ineficiente para usar en listas que tengan más que un número reducido de elementos. Incluso entre los
          algoritmos de ordenamiento de orden O(n2), otros procedimientos como el ordenamiento por inserción son considerados 
          más eficientes

        * Reglas:
            - Los apuntadores que rigen nuestro algoritmo deben de ir al final y regresar el mimso numero de veces de posiciones de 
            nuestro arreglo.
                -> Si nuestro arreglo tiene 5 posiciones, nuestros apuntadores deben de ir al final y regresar 5 veces
            -cada vez que se cumple la condicion que nosotros asignamos nuestros apuntadores deben de intercambiar los números
            -Nunca podemos de perder de vista el número. Para eso usamos uan variable auxiliar


    2. Insertion sort:
        * Recursos:
            - http://lwh.free.fr/pages/algo/tri/tri_insertion_es.html

        * La idea de este algoritmo de ordenación consiste en ir insertando un elemento de la lista ó un arreglo en la parte ordenada
          de la misma, asumiendo que el primer elemento es la parte ordenada, el algoritmo ira comparando un elemento de la parte 
          desordenada de la lista con los elementos de la parte ordenada, insertando el elemento en la posición correcta dentro de 
          la parte ordenada, y así sucesivamente hasta obtener la lista ordenada.

        * Requiere O(n²) operaciones para ordenar una lista de n elementos.
        * En el caso más favorable (todos los datos ordenados) tiene un orden de complejidad de n (lineal), minetras que en el caso más
          desfavorable tiene un orden de complejidad de n cuadrada 
        * la flecha o apuntador siempre se mueve hacia adelante; nunca hacia atras

    3. Shell sort:
        * Recusos:
            - https://es.wikipedia.org/wiki/Ordenamiento_Shell
            - https://www.youtube.com/watch?v=AeCeFdSoPEM
            - https://www.youtube.com/watch?v=rZIt5XnbrOc

        * Shell: Usando un ordenamiento O(n2) como el ordenamiento de burbuja o el ordenamiento por inserción
        * El Shell sort es una generalización del ordenamiento por inserción, teniendo en cuenta dos observaciones:
            1. El ordenamiento por inserción es eficiente si la entrada está "casi ordenada".
            2. El ordenamiento por inserción es ineficiente, en general, porque mueve los valores sólo una posición cada vez.
        
        * Mejora del ordenamiento por insercion, por que:
        * Pude comparar elementos separados por un espacio de varias posiciones, permitiendo que un elemento de pasos más grandes 
          hacia su posicion esperada.
        * En el transcurso del ordenmiento esos saltos se van acortando
        * Una ves que el vector queda casi ordenadado, el ulitimo paso es ordenar por insercion, garantizando de esa manera el orden 
          total del vector

        * FORMULA: k = n/2
                 "k" --> distancia de los elementos que se van a comparar. Utilizamos este numero para saber cual es el otro numero
                         con el que vamos a comparar los datos, por ejemplo 10 + k(5) tomamos el valor que está a 5 posiciones del 10
                         - Si llegara a ser correcto el orden que buscamos lo dejamos así, de lo contrario intercambiamos posiciones.
                         - Al volver a ciclar el ciclo, tomamos el valor de K anterior y lo dividimos entre 2(tomamos el valor entero(casteo)) 
                           ahora vamos a comparar el 10 con el valor que está la mitad de k posicones adelante
                         - Al llegar al momento en el que K es igual a 1, entonces hacemos un *ordenamiento de insercion*
                 "n" --> cantidad de elementos en el arreglo


    4. Merge sort (Directo):
        * Recursos:
         - http://www.pythondiario.com/2018/08/ordenamiento-por-mezcla-merge-sort.html
         - https://es.wikipedia.org/wiki/Ordenamiento_por_mezcla
         - https://www.ecured.cu/MergeSort
         - https://www.youtube.com/watch?v=Xhlf6f26M7Y

        * es un algoritmo de ordenamiento externo
        * Es de complejidad O(n log n)
        * El algoritmo de ordenamiento por mezcla (merge sort en inglés) es un algoritmo de ordenamiento externo estable basado 
          en la técnica divide y vencerás.
        * Se va partiendo a la mitad hasta que tengamos sublistas de un elemento(usando recursividad)
        * La idea de los algoritmos de ordenación por mezcla es dividir la matriz por la mitad una y otra vez hasta que cada pieza 
          tenga solo un elemento de longitud. Luego esos elementos se vuelven a juntar (mezclados) en orden de clasificación.

        * El ordenamiento por mezcla incorpora dos ideas principales para mejorar su tiempo de ejecución:
            1. Una lista pequeña necesitará menos pasos para ordenarse que una lista grande.
            2. Se necesitan menos pasos para construir una lista ordenada a partir de dos listas también ordenadas, que a partir 
            de dos listas desordenadas. Por ejemplo, sólo será necesario entrelazar cada lista una vez que están ordenadas.
            (EXTRA by: Santiago Yeomans) : Si una lista tiene 0 o 1 elementos, entonces ya está ordenada.
            
        * Si la lista es impar, se divide la longitud entre 2 y la lista de la izquierda es mayor a la de la derecha en 1.

     * * * * Comparación con otros algoritmos de ordenamiento:* * * *
            Aunque heapsort tiene los mismos límites de tiempo que merge sort, requiere sólo Θ(1) espacio auxiliar en lugar del Θ(n) 
            de merge sort, y es a menudo más rápido en implementaciones prácticas. Quicksort, sin embargo, es considerado por mucho
            como el más rápido algoritmo de ordenamiento de propósito general. En el lado bueno, merge sort es un ordenamiento
            estable, paraleliza mejor, y es más eficiente manejando medios secuenciales de acceso lento. Merge sort es a menudo la
            mejor opción para ordenar una lista enlazada: en esta situación es relativamente fácil implementar merge sort de manera
            que sólo requiera Θ(1) espacio extra, y el mal rendimiento de las listas enlazadas ante el acceso aleatorio hace que 
            otros algoritmos (como quicksort) den un bajo rendimiento, y para otros (como heapsort) sea algo imposible.

            Para Perl 5.8, merge sort es el algoritmo de ordenamiento por defecto (lo era quicksort en versiones anteriores de Perl).
             En Java los métodos de ordenación de Arrays usan merge sort o una modificación de quicksort dependiendo de los tipos de
             datos y por cuestiones de eficiencia cambian a ordenamiento por inserción cuando se están ordenando menos de siete 
             elementos en el array.
    
    4. Merge sort (Natural):
        *Recursos:
            - https://www.youtube.com/watch?v=GgPYYiVtVQM&list=PLCLpAU8VN0j4RGemFfybZrWoSX57NbEq9&index=64

        * Una variante al merge sort Directo
        * En teoria es mas eficiente
        * Normalente se usa para ordenar archivos
        * Utiliza 3 arreglo: Arreglo Original, Arreglo Auxiliar 1 y otreo arreglo auxiliar
        * se encarga de sacar tuplas de datos de valores ya ordenados del vector original.
        * Una ves sacadas las tuplas con sus parejas, hacemos la FUSION(mezcla directa)
        * ver video[LINK] en recursos


    Quick sort:




Algoritmos de Busqueda:
    *Se encarga de encontrar en una lista de datos un valor que nosotros determinamos

    1. Busqueda Binaria:
        *Encontrar un valor en una lista ordenada. Basado en "Divide y venceras"
        *Funciona dividiendo a la mitad repetidamente la lista o el arreglo, que podría contener el dato buscado, hasta reducirlo a 
            un valor

        *Reglas:
            1. El arreglo debe tener valor unicos, es decir, no se deben repetir. (ID)
                <Un ID:> es un identificador que nos ayuda a que aunque nosotros tengamos datos repetidos, siempre hay algo que los
                 identifica el uno del otro. Osea nos aydua a identificar cuando tengamos varios iguales.
            2. El arreglo debe estar ordenado de manera ascendente, es decir de menor a mayor.

            NOTA: Para poder programarlo necesitamos 3 apuntadores y el uso de casting. (Apuntador1, Apuntador2 y ApuntadorPM (punto medio))
            *En busqueda binaria siempre el apuntoador1 compienza en la posicion 1(arreglo[0])de la lista o arreglo
            *Apuntador2: Siempre inicia en la ultima posicon del arreglo
            *ApuntadorPM: Posicion: (Apuntador1 + Apuntador2) / 2 ---------> Sumamos la posicion del apuntador 1 y 2 y lo dividimos entre 2
                            y lo casteamos, osea le quitamos los decimales

            *Obtenemos valor  del apuntador punto medio y lo comparamos con el valor buscado
                -Es valor buscado igual a valor punto medio ----> True: termina el programa / False: Continuamos con la siguente inst.
                -Es valor buscado mayor a valor punto medio ----> True: A1 = Posicion Apm + 1 / False
                -Es valor buscado menor a valor punto medio ----> True: A2 = Posicion Apm - 1

                Codigo en java





    Listas en java:
        *Las listas, son un tipo de dato abstracto que nos permite almacenar datos de una forma organizada al igual que los vectores,
        pero, a diferenia de estos, esta estructura, está estructura es dinámica, por lo que no es necesario conocer la cantidad de
        elementos que va a contener.
        *En una lista, cada elemento apnta al siguente elemento, excepto el ultimo que tiene él último elemento, el cual no tiene un
         sucesor y por tal motivo el valor del enlace es null.
        *En este caso, los elementos son registros que contienen el dato a almacenar y un enlace al siguente elemento.
        *Los elementos de una lista suelen recibir el nombre de nodos de lista.
        *Cada nodo tiene dos campos:
            - 1.Con información
            - 2.Con un apuntador al siguente nodo de la lista.

        *Tipos de listas en java:
            *Dependiendo del procedimiento de insercion y extraccion de nodos en la lista , tenemos los siguientes tipos:
                1. Lista tipo Pila
                    - Una lista es de tipo pila, cuando las inserciones y extracciones se realizan por el mismo lado de la lista.
                    - Caracterísitca: El último elemento en entrar es el primero en salir
                    - Se les conoce como LIFO (Last in, First Out)  ---> último en entrar, primero en salir
                    - una pila al ser una lista pude almacenar en el campo de información de un nodo cualquier tipo de valor:
                    valores enteros, valores flotantes, cadenas de caracteres, objetos, etc.
                2. Lista tipo cola
                3. Lista genéricas
                
    |
    |
    |
    |
    |
    v


*** ESTRUCTURA DE DATOS ***
    https://es.wikipedia.org/wiki/Estructura_de_datos

    * En ciencias de la computación, una estructura de datos es una forma particular de organizar datos en una computadora para
    que puedan ser utilizados de manera eficiente. Diferentes tipos de estructuras de datos son adecuados para diferentes tipos 
    de aplicaciones, y algunos son altamente especializados para tareas específicas.

    * Las estrucutras de datos son un medio para manejar grandes canitadades de datos de manera eficiente/ para usos tales como:
      grandes bases de datos y servicios de indización de internet. Por lo general, ---> las estructuras de datos eficientes son 
      clave para diseñara alogritmos eficientes <--- Algunos métoso formales de disño y lenguajes de progrmacion destacan las
      estrucuras de datos, en lugar de los algoritmos, como el facotr clave de organizacion en el diseño de software.

      * Tipos:
        1. Vector: - es una serie de elementos en un orden específico, por lo general todos del mismo tipo (si bien los elementos 
                     pueden ser de casi cualquier tipo). Se accede a los elementos utilizando un entero como índice para especificar
                     el elemento que se requiere.

        2. Vector Asociativo (también llamado diccionario o mapa):
                    - es una variante más flexible que una matriz, en la que se puede añadir y eliminar libremente pares nombre-valor
                    - Una tabla de hash es una implementación usual de un arreglo asociativo.

        3. Registro (también llamado tupla o estructura):
        4. Unión:
        5. Tipo variante:
        6. Conjunto:
        7. Multiconjunto:
        8. Grafo:
        9. Árbol:
        10. Clase:

CURSO ESTRUCTURA DE DATOS DE MasterHeHeGar:
*** https://www.youtube.com/playlist?list=PLCLpAU8VN0j4RGemFfybZrWoSX57NbEq9 ***

Cap. 08:
    * Recursividad:
        * ¿Que es la recursiva?
            Es un proceso que ya ocurrio y que vuelve a ocurrir
            -> Es un metodo que se llama a si mismo <-
            - procedimiento para resolver un problema compeljo reduciendolo en uno o más subproblemas

        * Caracterísitcas de la Recursividad:
            - Misma estrucutra que el problema original
            - Más simple de resolver que el problema original
            - Cada subproblema se divide, usando el mismo procedimiento, en subproblemas aún mas simples
            - Los subproblemas llegaran a ser tan simples que no hará falta dividirlos para resolverlos
        
        * Ejemplo Recursivo:
            1) Recorrer un trayecto de un origen a un destino
                |   |
                |   |
                |   -> Dar un paso desde el origen hacia el destino.
                -> Dar(n -1) pasos hacia el destino desde el nuevo origen
            
            2) Subir una escalera
                |   |
                |   |
                |   -> Subir un escalon.
                -> subir los (n -1) escalones restantes
                
        * Estrucutura general de un algoritmo Recursivo

            Problema ---> Caso Base: Respuesta Explicita
                     ---> Dominio: Problema -1



CLASE SALINAS NOTAS:

    Recursividad:
    * En java se copian refrencias al llamar objetos, mientras que en primitivos no
    * La recursion debe acercarse al caso base
    * todos lo probelams recursivos se puden resolver de manera iterativa
    * La carga computacional de un metodo recurisvo es mayor a la manera iterativa 
    * Lo peor que nos puede ocurrrir en recurivismo: que un valor se cuelva a calcualar y calcular
    * En el ejmplo se la serie de fibonacci tarda mucho por que se calculan muchas veces los mismos valores
      El 2 se calcula 34 veces.

        Notas Tarea:
    
        Fuente: https://www.linkedin.com/learning/java-avanzado/recursividad-directa?u=35799868
            
            Recursividad Directa Video:
                ¿Que es recursividad?
                    Cuando tenemos un metodo que se llama a si mismo
                    es infinita hasta que la terminemos
                
                Tipos:
                    -Directa: Se va a mandar llamar el metodo o funcion las veces que sea necesario con un limite finito
                    - Indirecta

                
                Codigo:
                    static long factorial(int n){
                        
                        if(n<=1){
                            return 1:
                        }else{
                            long resultado = n*factorial(n-1);
                            return resultado;
                        }
                    }

            Recursividad Indirecta Video:
                ¿Que es?
                    el metodo A llama al B y el B al A
                
                - Se usan condicionales y ciclos para decidirt cuando va a terminar
                - Esto no va acabar hasta que tenga que acabar, por eso se llama recursividad
                - Y es indirecta por que el A manda a llamar al B y el B al A

                 Codigo:
                    static void metodoA(char x){
                        if (x>"A"){
                            metodoB(x){
                                Syso(x)
                            }
                        }

                    static void metodoB(char x){
                            metodoA(--x);
                        }
                    }

        Notas Videos LinkedIn learning:
            *Head Recursion: Recive en los parametros solo un int n
            * Breaking condition: condicion que permite al metodo terminar, en caso contrario el metodo sería infinito

            Caculando Factoriales:
                De manera iterativa: ultizariamos un for que va ir ciclando
                                    factorial(n) = n * (n-1) * (n-2) * ....1
                
                De manera recursiva: factorial(n) = n * factorial(n-1)

            *StackOverflow: Ocurre cuando no tenemos un breaking point por que el metodo sigue metiendo cosas en el stack (pila)
                            en el factorial, el ultimo numero que saca(el primero en entrar) es el resultado del factorial
                            - Se puede alcanzar el stack StackOverflow si el breaking condition is to deep :)


            *Tail Recursion: Recive en los parametro un int n y un acumulador
                - Este tipo de recursion no necesita stacks
                - Utiliza acumuladores