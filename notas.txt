*****   Estructura de datos *****

Algoritmos de ordenamiento: 
    - Un "buen algoritmo" de ordenamiento requiere de un orden nlogn comparaciones.
    - Recursos:
        https://www.monografias.com/trabajos/algordenam/algordenam.shtml

    1. Bubble sort:
       * Recursos:
            - https://www.ecured.cu/Ordenamiento_de_burbuja
            - geekpedia de ernesto

        * Compara dos numeros entre si para poder ir haciendo el ordenmaineto de menor a mayor.
        * Puede ordenar de menor a mayor o viceversa.
        * número de comparaciones pertenece al orden de n cuadrado.
        * A pesar de que el ordenamiento de burbuja es uno de los algoritmos más sencillos de implementar, su orden O(n2) 
          lo hace muy ineficiente para usar en listas que tengan más que un número reducido de elementos. Incluso entre los
          algoritmos de ordenamiento de orden O(n2), otros procedimientos como el ordenamiento por inserción son considerados 
          más eficientes

        * Reglas:
            - Los apuntadores que rigen nuestro algoritmo deben de ir al final y regresar el mimso numero de veces de posiciones de 
            nuestro arreglo.
                -> Si nuestro arreglo tiene 5 posiciones, nuestros apuntadores deben de ir al final y regresar 5 veces
            -cada vez que se cumple la condicion que nosotros asignamos nuestros apuntadores deben de intercambiar los números
            -Nunca podemos de perder de vista el número. Para eso usamos uan variable auxiliar


    2. Insertion sort:
        * Recursos:
            - http://lwh.free.fr/pages/algo/tri/tri_insertion_es.html

        * La idea de este algoritmo de ordenación consiste en ir insertando un elemento de la lista ó un arreglo en la parte ordenada
          de la misma, asumiendo que el primer elemento es la parte ordenada, el algoritmo ira comparando un elemento de la parte 
          desordenada de la lista con los elementos de la parte ordenada, insertando el elemento en la posición correcta dentro de 
          la parte ordenada, y así sucesivamente hasta obtener la lista ordenada.

        * Requiere O(n²) operaciones para ordenar una lista de n elementos.
        * En el caso más favorable (todos los datos ordenados) tiene un orden de complejidad de n (lineal), minetras que en el caso más
          desfavorable tiene un orden de complejidad de n cuadrada 
        * la flecha o apuntador siempre se mueve hacia adelante; nunca hacia atras

    3. Shell sort:
        * Recusos:
            - https://es.wikipedia.org/wiki/Ordenamiento_Shell
            - https://www.youtube.com/watch?v=AeCeFdSoPEM
            - https://www.youtube.com/watch?v=rZIt5XnbrOc

        * Shell: Usando un ordenamiento O(n2) como el ordenamiento de burbuja o el ordenamiento por inserción
        * El Shell sort es una generalización del ordenamiento por inserción, teniendo en cuenta dos observaciones:
            1. El ordenamiento por inserción es eficiente si la entrada está "casi ordenada".
            2. El ordenamiento por inserción es ineficiente, en general, porque mueve los valores sólo una posición cada vez.
        
        * Mejora del ordenamiento por insercion, por que:
        * Pude comparar elementos separados por un espacio de varias posiciones, permitiendo que un elemento de pasos más grandes 
          hacia su posicion esperada.
        * En el transcurso del ordenmiento esos saltos se van acortando
        * Una ves que el vector queda casi ordenadado, el ulitimo paso es ordenar por insercion, garantizando de esa manera el orden 
          total del vector

        * FORMULA: k = n/2
                 "k" --> distancia de los elementos que se van a comparar. Utilizamos este numero para saber cual es el otro numero
                         con el que vamos a comparar los datos, por ejemplo 10 + k(5) tomamos el valor que está a 5 posiciones del 10
                         - Si llegara a ser correcto el orden que buscamos lo dejamos así, de lo contrario intercambiamos posiciones.
                         - Al volver a ciclar el ciclo, tomamos el valor de K anterior y lo dividimos entre 2(tomamos el valor entero(casteo)) 
                           ahora vamos a comparar el 10 con el valor que está la mitad de k posicones adelante
                         - Al llegar al momento en el que K es igual a 1, entonces hacemos un *ordenamiento de insercion*
                 "n" --> cantidad de elementos en el arreglo


    4. Merge sort:
        * Recursos:
         - http://www.pythondiario.com/2018/08/ordenamiento-por-mezcla-merge-sort.html
         - https://es.wikipedia.org/wiki/Ordenamiento_por_mezcla
         - https://www.ecured.cu/MergeSort
         - https://www.youtube.com/watch?v=Xhlf6f26M7Y

        * es un algoritmo de ordenamiento externo
        * Es de complejidad O(n log n)
        * El algoritmo de ordenamiento por mezcla (merge sort en inglés) es un algoritmo de ordenamiento externo estable basado 
          en la técnica divide y vencerás.
        * Se va partiendo a la mitad hasta que tengamos sublistas de un elemento(usando recursividad)
        * La idea de los algoritmos de ordenación por mezcla es dividir la matriz por la mitad una y otra vez hasta que cada pieza 
          tenga solo un elemento de longitud. Luego esos elementos se vuelven a juntar (mezclados) en orden de clasificación.

        * El ordenamiento por mezcla incorpora dos ideas principales para mejorar su tiempo de ejecución:
            1. Una lista pequeña necesitará menos pasos para ordenarse que una lista grande.
            2. Se necesitan menos pasos para construir una lista ordenada a partir de dos listas también ordenadas, que a partir 
            de dos listas desordenadas. Por ejemplo, sólo será necesario entrelazar cada lista una vez que están ordenadas.
            (EXTRA by: Santiago Yeomans) : Si una lista tiene 0 o 1 elementos, entonces ya está ordenada.
            
        * Si la lista es impar, se divide la longitud entre 2 y la lista de la izquierda es mayor a la de la derecha en 1.

     * * * * Comparación con otros algoritmos de ordenamiento:* * * *
            Aunque heapsort tiene los mismos límites de tiempo que merge sort, requiere sólo Θ(1) espacio auxiliar en lugar del Θ(n) 
            de merge sort, y es a menudo más rápido en implementaciones prácticas. Quicksort, sin embargo, es considerado por mucho
            como el más rápido algoritmo de ordenamiento de propósito general. En el lado bueno, merge sort es un ordenamiento
            estable, paraleliza mejor, y es más eficiente manejando medios secuenciales de acceso lento. Merge sort es a menudo la
            mejor opción para ordenar una lista enlazada: en esta situación es relativamente fácil implementar merge sort de manera
            que sólo requiera Θ(1) espacio extra, y el mal rendimiento de las listas enlazadas ante el acceso aleatorio hace que 
            otros algoritmos (como quicksort) den un bajo rendimiento, y para otros (como heapsort) sea algo imposible.

            Para Perl 5.8, merge sort es el algoritmo de ordenamiento por defecto (lo era quicksort en versiones anteriores de Perl).
             En Java los métodos de ordenación de Arrays usan merge sort o una modificación de quicksort dependiendo de los tipos de
             datos y por cuestiones de eficiencia cambian a ordenamiento por inserción cuando se están ordenando menos de siete 
             elementos en el array.





    Quick sort:




Algoritmos de Busqueda:
    *Se encarga de encontrar en una lista de datos un valor que nosotros determinamos

    1. Busqueda Binaria:
        *Encontrar un valor en una lista ordenada. Basado en "Divide y venceras"
        *Funciona dividiendo a la mitad repetidamente la lista o el arreglo, que podría contener el dato buscado, hasta reducirlo a 
            un valor

        *Reglas:
            1. El arreglo debe tener valor unicos, es decir, no se deben repetir. (ID)
                <Un ID:> es un identificador que nos ayuda a que aunque nosotros tengamos datos repetidos, siempre hay algo que los
                 identifica el uno del otro. Osea nos aydua a identificar cuando tengamos varios iguales.
            2. El arreglo debe estar ordenado de manera ascendente, es decir de menor a mayor.

            NOTA: Para poder programarlo necesitamos 3 apuntadores y el uso de casting. (Apuntador1, Apuntador2 y ApuntadorPM (punto medio))
            *En busqueda binaria siempre el apuntoador1 compienza en la posicion 1(arreglo[0])de la lista o arreglo
            *Apuntador2: Siempre inicia en la ultima posicon del arreglo
            *ApuntadorPM: Posicion: (Apuntador1 + Apuntador2) / 2 ---------> Sumamos la posicion del apuntador 1 y 2 y lo dividimos entre 2
                            y lo casteamos, osea le quitamos los decimales

            *Obtenemos valor  del apuntador punto medio y lo comparamos con el valor buscado
                -Es valor buscado igual a valor punto medio ----> True: termina el programa / False: Continuamos con la siguente inst.
                -Es valor buscado mayor a valor punto medio ----> True: A1 = Posicion Apm + 1 / False
                -Es valor buscado menor a valor punto medio ----> True: A2 = Posicion Apm - 1

                Codigo en java





    Listas en java:
        *Las listas, son un tipo de dato abstracto que nos permite almacenar datos de una forma organizada al igual que los vectores,
        pero, a diferenia de estos, esta estructura, está estructura es dinámica, por lo que no es necesario conocer la cantidad de
        elementos que va a contener.
        *En una lista, cada elemento apnta al siguente elemento, excepto el ultimo que tiene él último elemento, el cual no tiene un
         sucesor y por tal motivo el valor del enlace es null.
        *En este caso, los elementos son registros que contienen el dato a almacenar y un enlace al siguente elemento.
        *Los elementos de una lista suelen recibir el nombre de nodos de lista.
        *Cada nodo tiene dos campos:
            - 1.Con información
            - 2.Con un apuntador al siguente nodo de la lista.

        *Tipos de listas en java:
            *Dependiendo del procedimiento de insercion y extraccion de nodos en la lista , tenemos los siguientes tipos:
                1. Lista tipo Pila
                    - Una lista es de tipo pila, cuando las inserciones y extracciones se realizan por el mismo lado de la lista.
                    - Caracterísitca: El último elemento en entrar es el primero en salir
                    - Se les conoce como LIFO (Last in, First Out)  ---> último en entrar, primero en salir
                    - una pila al ser una lista pude almacenar en el campo de información de un nodo cualquier tipo de valor:
                    valores enteros, valores flotantes, cadenas de caracteres, objetos, etc.
                2. Lista tipo cola
                3. Lista genéricas


    |
    |
    |
    |
    |
    v


*** ESTRUCTURA DE DATOS ***
    https://es.wikipedia.org/wiki/Estructura_de_datos

    * En ciencias de la computación, una estructura de datos es una forma particular de organizar datos en una computadora para
    que puedan ser utilizados de manera eficiente. Diferentes tipos de estructuras de datos son adecuados para diferentes tipos 
    de aplicaciones, y algunos son altamente especializados para tareas específicas.

    * Las estrucutras de datos son un medio para manejar grandes canitadades de datos de manera eficiente/ para usos tales como:
      grandes bases de datos y servicios de indización de internet. Por lo general, ---> las estructuras de datos eficientes son 
      clave para diseñara alogritmos eficientes <--- Algunos métoso formales de disño y lenguajes de progrmacion destacan las
      estrucuras de datos, en lugar de los algoritmos, como el facotr clave de organizacion en el diseño de software.

      * Tipos:
        1. Vector: - es una serie de elementos en un orden específico, por lo general todos del mismo tipo (si bien los elementos 
                     pueden ser de casi cualquier tipo). Se accede a los elementos utilizando un entero como índice para especificar
                     el elemento que se requiere.

        2. Vector Asociativo (también llamado diccionario o mapa):
                    - es una variante más flexible que una matriz, en la que se puede añadir y eliminar libremente pares nombre-valor
                    - Una tabla de hash es una implementación usual de un arreglo asociativo.

        3. Registro (también llamado tupla o estructura):
        4. Unión:
        5. Tipo variante:
        6. Conjunto:
        7. Multiconjunto:
        8. Grafo:
        9. Árbol:
        10. Clase: